# rust

The playground for Rust

### Different between Eq and PartialEq

- El を満たすためには, `反射律(reflective)`、`対称律(symmetric)`、`推移律(transitive)`を満たす必要がある。これは Java の Object@equals メソッドをオーバーライドする時の条件と同じ。
- ただ常に `反射律`を満たすことはできない。例えば, f32 の NaN(Not a Number) は Nan == Nan => false となってしまう。この`反射律`の条件だけは満たさなくても良いとしたものが `PartialEq`. `PartialOrd` も同様.
- NaN が含まれている Vec<i32> をソートすると `unwarp パニック`になる

### 静的ディスパッチ、動的ディスパッチ

- インスタンスからメソッドを呼び出す場合、コンパイル時にどのインスタンスからメソッドが呼び出されるかわかっているため処理を高速化できる → 「静的ディスパッチ」
- どのインスタンスから呼び出されるかわからない場合、実行時に決める → 「動的ディスパッチ」 動的ディスパッチの例としては以下のような場合で、for で繰り返し処理をするような際に、tweet() メソッドを呼び出した時にコンパイル時にはどのインスタンスかは分からない。この「静的ディスパッチ」では解決できない場合は `dyn` を使って動的ディスパッチを使う.

```rust
let dove = Dove{}
let duck = Duck{}
let birds: Vec<Box<dyn Tweet>> = vec![Box::new(dove), Box::new(duck)];
for bird in birds{
  bird.tweet()
}
```

### マーカトレイト

- `Send`: スレッド間をまたいで所有権を転送（委譲）できることを示す
  - スレッド間を転送してはいけない型を転送しようとするとコンパイルエラーとなり間違った方の仕様を防ぐことができる
- `Sync`: 複数のスレッドから安全にアクセスできることを示す
  - 例えば、`Mutex` は `lock` メソッドによる排他制御によって複数のスレッドから安全にアクセスできるので、Sync を実装している
  - `Sync` を実装していない型を複数のスレッドからアクセスするとコンパイルエラーになる

### Future

- タスクが作成された時点では実行されておらず、ランタイム（非同期ランタイム： Future の実行タイミングを制御し、必要なタイミングで処理を走らせる）に乗った時点でスケジューリングされ、実行される。
  - 「実行」するかどうかの判断は、 `poll()` （ポーリング）によってチェックされる。
  - チェックする主体は `Waker(std::task::Waker)` であり poll 関数の引数として渡される `Context` 内にラップされている。
  - `Poll::Pending` が返されると `poll()` はまた`他のタスクが実行状態でなくなる`まで呼ばれず、他のタスクを実行する。（他のタスクを処理した後に再度 poll する）
  - `Poll::Ready<T>` が返されるとタスクが実行完了となり、ランタイムは次の実行状態に移る。
  - このポーリングを繰り返しながら実行するランタイムのことを `Executor` と呼ぶ。
