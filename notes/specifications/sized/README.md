### Sized とは何か

- 概要: Rust には Sized というトレイトがあり、一部の例外を除いて暗黙のうちに実装されている。Sized が実装されていない型は `Dynamically Sized Type` と呼ばれ、これらのデータは `fat ポインタ`を経由してアクセスする
- [reference](https://qnighy.hatenablog.com/entry/2017/03/04/131311#:~:text=Sized%E3%81%AF%E6%A8%99%E6%BA%96%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%A7%E5%AE%9A%E7%BE%A9%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E3%81%A7%E3%81%82%E3%82%8B%E3%80%82&text=Sized%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E3%81%AF%E6%AC%A1%E3%81%AE2%E3%81%A4%E3%81%AE%E6%84%8F%E5%91%B3%E3%82%92%E3%82%82%E3%81%A4%E3%82%88%E3%81%86%E3%81%A0%E3%80%82&text=Sized%E3%81%AF%E5%AE%9F%E8%A3%85%E3%82%92%E6%8C%81%E3%81%9F,%E7%89%B9%E5%88%A5%E6%89%B1%E3%81%84%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%80%82)

- `Sized` を実装する型は、データ本体以外の余計な情報を持たない。(逆に、`Sized` でない場合は、余計な情報が必要になる。それらの余計な情報を持つために `fat pointer` が採用される)
- `X: ?Sized` という専用構文を使って、 Sized を仮定しないことを明示した場合、プログラマが明示しなくても、型変数は Sized を実装していることが仮定される

#### プログラム中での要請

- let やパターンマッチで束縛できる変数の型は Sized でなければならない
- `関数の引数と戻り値の型は Sized でなければならない`
- ` struct の最後を除く全ての要素``と、enum の全ての要素 `は、 Sized でなければならない

#### ポインタのサイズ

- Sized を実装しない型へのポインタは、通常 fat pointer で実装される。例えば、x86-64 環境なら、 `*const T`, `*mut T`, `&'a T`, `&mut 'a T`, `Box<T>` などのポインタ自身の大きさは通常 `8byte` だが、`T` が `Sized でないとき`は `16byte` になる。
- fat pointer は何を保持しているのか:

```text
Sizedでない型は限られる。具体的には:

[i64] などのスライス。
str 文字列スライス。
Read や Fn(i32) -> i32 などのトレイトオブジェクト。
Sizedでない要素を末尾にもつstruct。
これらの値へのポインタは16byteになる。最初の8byteにはデータの先頭番地が入っている。続く8byteには、以下の内容が入っている。

&[i64] の場合: スライスの要素数。
&str の場合: バイト数。
&Read の場合: vtableへのポインタ。
これらを末尾要素にもつstruct: 末尾要素のfat pointerの内容を継承する。
```
